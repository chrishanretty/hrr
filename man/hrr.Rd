% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hrr.R
\name{hrr}
\alias{hrr}
\title{Estimate a hierarchical related regression model}
\usage{
hrr(
  f,
  data,
  ps,
  aux,
  res,
  areavar,
  weightvar,
  testing = FALSE,
  adjust = FALSE,
  overdispersed = FALSE,
  threading = FALSE,
  probs = c(0.025, 0.5, 0.975),
  mrp_only = FALSE,
  stan_control = list(adapt_delta = 0.99, max_treedepth = 12),
  ...
)
}
\arguments{
\item{f}{a two-part formula, with categorical predictors found in
the post-stratification frame followed by a vertical bar and
(continuous or categorical) predictors found in the auxiliary
area-level data.}

\item{data}{a data frame containing the outcome variable and the
categorical predictors specified in the first part of formula
\code{f}. The data frame must also contain the area identifier
named in \code{areavar}.}

\item{ps}{a data frame containing the categorical predictors
specified in the first part of formula \code{f}. The data frame
must also contain the area identifier named in \code{areavar}, and
the post-stratification weights named in \code{weightvar}.}

\item{aux}{a data frame containing the continuous or categorical
predictors specified in the second part of formula
\code{f}. The data frame must also contain the area identified
named in \code{areavar}.}

\item{res}{a data frame containing the aggregate-level outcomes for
each area. The data frame must include the area identifier
named in \code{areavar}, and variables names equivalent to the
levels of the response variable found in \code{data}.}

\item{areavar}{a character string giving the name of an area
identifier found in the different input data frames (\code{data},
\code{ps}, \code{aux}, \code{res})}

\item{weightvar}{a character string giving the name of the variable
in data frame \code{ps} which contains the post-stratification
weights. This is not the name of any variable in \code{data}
containing survey weights: the package does not support such
weights.}

\item{testing}{a logical value. If \code{testing} is equal to TRUE, then
the return value is a list containing Stan code and a list of
data to pass to Stan. If \code{testing} is equal to FALSE, the model
is estimated. Setting \code{testing} to TRUE can be useful to
prototype Stan code which is then manually tweaked.}

\item{adjust}{a logical value. If \code{adjust} is equal to TRUE, the
model for individual level outcomes includes a parameter not
found in the aggregate model. This parameter can capture survey
effects. If \code{adjust} is equal to FALSE (the default) the
standard hierarchical related regression model is estimated.}

\item{overdispersed}{a logical value. If \code{overdispersed} is equal
to TRUE, binary or categorical counts are modelled using a
Beta-Binomial or Dirichlet-Multinomial distribution rather than
a binomial or multinomial distribution.}

\item{threading}{an integer. If \code{threading} is equal to zero (the
default), hrr estimates the model using RStan, with each chain
operating on at most one core. If \code{threading} is a non-zero
number, hrr estimates the model using cmdstanr, with
within-chain multi-threading and \code{threading} threads per chain.}

\item{probs}{a vector of probabilities. This parameter affects the
summary statistics returned.}

\item{mrp_only}{a logical value. If \code{mrp_only} is equal to TRUE,
then only individual responses are modelled. If \code{mrp_only} is
equal to FALSE (the default), aggregate outcomes are also
modelled.}

\item{stan_control}{a list of arguments passed to RStan or
cmdstanr's control argument.}

\item{...}{other arguments passed on RStan or (if threading > 0) to
cmdstanr.}
}
\value{
A list with entries \code{area_smry}, \code{grp_smry}, and \code{fit}.
}
\description{
\code{hrr} returns a list containing a Stan fit, a tidy data frame
of coefficients, and pre-calculated tables showing the popularity
of different options amongst different groups defined by the
categorical predictors in the model.
}
\examples{
data("toydat")
data("toypsf")

f <- cat_y ~ k_1 + k_2 + k_3 | x_1 + x_2

aux <- unique(toydat[,c("area", "x_1", "x_2")])
res <- unique(toydat[,c("area", "red", "green", "blue")])

## Generate Stan code and data for later use
mod <- hrr(f, data = toydat, ps = toypsf, aux = aux,
    res = res, areavar = "area", weightvar = "count",
    testing = TRUE, adjust = FALSE, overdispersed = TRUE)

## Computationally intensive bit
\dontrun{
mod <- hrr(f, data = toydat, ps = toypsf, aux = aux,
    res = res, areavar = "area", weightvar = "count",
    testing = FALSE, adjust = FALSE, overdispersed = TRUE,
    iter = 320, chains = 4, cores = 4)
}

}
